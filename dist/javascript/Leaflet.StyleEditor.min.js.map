{"version":3,"sources":["webpack://leafletstyleeditor/webpack/bootstrap","webpack://leafletstyleeditor/./src/typescript/options/index.ts","webpack://leafletstyleeditor/./src/typescript/StyleEditorClass.ts","webpack://leafletstyleeditor/./src/typescript/index.ts","webpack://leafletstyleeditor/external {\"commonjs\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://leafletstyleeditor/./src/typescript/Util.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorControlOptions.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorClassOptions.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorOptions.ts","webpack://leafletstyleeditor/./src/typescript/StyleEditorControl.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","StyleEditorControlOptions_1","DefaultStyleEditorControlOptions","StyleEditorClassOptions_1","DefaultStyleEditorClassOptions","StyleEditorOptions_1","DefaultStyleEditorOptions","Util_1","options_1","StyleEditorClass","L","Class","map","options","super","this","assign","Util","createInstance","createUi","editorUI","DomUtil","getContainer","styleEditorHeader","buttonNext","title","strings","tooltipNext","tooltipWrapper","tooltipUI","innerHTML","tooltip","DomEvent","disableScrollPropagation","disableClickPropagation","on","onNext","addEventListeners","events","forEach","event","onEvent","hideEditor","showTooltip","stopPropagation","children","getPanes","markerPane","index","length","element","removeClass","layer","layerIsIgnored","useGrouping","LayerGroup","Marker","Path","undefined","ignoreLayerTypes","some","layerType","styleEditor","type","toUpperCase","removeIndicators","fireEvent","addClass","eventName","showEditor","hideTooltip","StyleEditorClass_1","StyleEditorControl_1","StyleEditor","Control","StyleEditorControl","control","default","UtilOptions","instance","styleEditorEventPrefix","rgb","noHash","defaultColor","indexOf","replace","rgbArray","substring","split","withoutHash","_componentToHex","parseInt","currentElement","option","style","newStyle","setStyle","fireChangeEvent","color","hex","toString","rgbToHex","markers","controlMarkers","Array","isArray","keys","includes","filter","getMarkersForColor","defMarkers","defaultMarker","push","position","cancel","cancelTitle","colorRamp","markerType","defaultMarkerIcon","defaultMarkerColor","markerForm","geometryForm","forms","openOnLeafletDraw","openOnLeafletEditable","_1","styleEditorOptions","isEnabled","styleEditorClassOptions","disable","createUI","controlUI","cancelUI","toggle","enable","showCancelButton","hideCancelButton"],"mappings":"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","file":"javascript/Leaflet.StyleEditor.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StyleEditorControlOptions_1 = require(\"./StyleEditorControlOptions\");\nexports.DefaultStyleEditorControlOptions = StyleEditorControlOptions_1.DefaultStyleEditorControlOptions;\nconst StyleEditorClassOptions_1 = require(\"./StyleEditorClassOptions\");\nexports.DefaultStyleEditorClassOptions = StyleEditorClassOptions_1.DefaultStyleEditorClassOptions;\nconst StyleEditorOptions_1 = require(\"./StyleEditorOptions\");\nexports.DefaultStyleEditorOptions = StyleEditorOptions_1.DefaultStyleEditorOptions;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = require(\"./Util\");\nconst options_1 = require(\"./options\");\nclass StyleEditorClass extends L.Class {\n    constructor(map, options) {\n        super();\n        this.map = map;\n        this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorOptions), options);\n        Util_1.Util.createInstance(map, this.options);\n        this.createUi();\n    }\n    createUi() {\n        const editorUI = this.editorUI = L.DomUtil.create('div', 'leaflet-styleeditor', this.map.getContainer());\n        const styleEditorHeader = L.DomUtil.create('div', 'leaflet-styleeditor-header', editorUI);\n        const styleEditorInterior = L.DomUtil.create('div', 'leaflet-styleeditor-interior', editorUI);\n        const buttonNext = L.DomUtil.create('button', 'leaflet-styleeditor-button styleeditor-nextBtn', styleEditorHeader);\n        buttonNext.title = this.options.strings.tooltipNext;\n        const tooltipWrapper = this.tooltipUI = L.DomUtil.create('div', 'leaflet-styleeditor-tooltip-wrapper', this.map.getContainer());\n        const tooltip = L.DomUtil.create('div', 'leaflet-styleeditor-tooltip', tooltipWrapper);\n        tooltip.innerHTML = this.options.strings.tooltip;\n        // do not propagate scrolling events on the ui to the map\n        L.DomEvent.disableScrollPropagation(editorUI);\n        L.DomEvent.disableScrollPropagation(buttonNext);\n        // do not propagate click events on the ui to the map\n        L.DomEvent.disableClickPropagation(editorUI);\n        L.DomEvent.disableClickPropagation(buttonNext);\n        // select next layer to style\n        L.DomEvent.on(buttonNext, 'click', this.onNext, this);\n        this.addEventListeners(this.map);\n        //new StyleForm(map, editorUI, styleEditorInterior, new this.options.markerForm(), new this.options.geometryForm())\n    }\n    addEventListeners(map) {\n        this.options.events.forEach(event => map.on(event, this.onEvent));\n    }\n    onEvent(event) {\n        // TODO\n    }\n    onNext(event) {\n        this.hideEditor();\n        this.showTooltip();\n        event.stopPropagation();\n    }\n    removeIndicators() {\n        const children = this.map.getPanes().markerPane.children;\n        for (let index = 0; index < children.length; index++) {\n            const element = children[index];\n            L.DomUtil.removeClass(element, 'leaflet-styleeditor-marker-selected');\n        }\n    }\n    addEditClickEvents(layer) {\n        if (this.layerIsIgnored(layer)) {\n            return;\n        }\n        if (this.options.useGrouping && layer instanceof L.LayerGroup) {\n            //this.options._layerGroups.push(layer)\n        }\n        else if (layer instanceof L.Marker || layer instanceof L.Path) {\n            //let evt = layer.on('click', this.initChangeStyle, this)\n            //this.options._editLayers.push(evt)\n        }\n    }\n    layerIsIgnored(layer) {\n        if (layer === undefined) {\n            return false;\n        }\n        return this.options.ignoreLayerTypes.some(layerType => layer.styleEditor && layer.styleEditor.type.toUpperCase() === layerType.toUpperCase());\n    }\n    hideEditor() {\n        L.DomUtil.removeClass(this.editorUI, 'editor-enabled');\n        this.removeIndicators();\n        this.fireEvent('hidden');\n    }\n    showEditor() {\n        L.DomUtil.addClass(this.editorUI, 'editor-enabled');\n        this.fireEvent('visible');\n    }\n    showTooltip() {\n        L.DomUtil.removeClass(this.tooltipUI, 'leaflet-styleeditor-hidden');\n    }\n    hideTooltip() {\n        L.DomUtil.addClass(this.tooltipUI, 'leaflet-styleeditor-hidden');\n    }\n    fireEvent(eventName) {\n    }\n    enable() {\n        //TODO this.addClickEvents()\n        this.showTooltip();\n        this.showEditor();\n    }\n    disable() {\n        //TODO this.removeClickEvents()\n        this.hideTooltip();\n        this.hideEditor();\n    }\n}\nexports.StyleEditorClass = StyleEditorClass;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"leaflet\");\nconst StyleEditorClass_1 = require(\"./StyleEditorClass\");\nconst StyleEditorControl_1 = require(\"./StyleEditorControl\");\nrequire('../css/Leaflet.StyleEditor.css');\nL.StyleEditor = StyleEditorClass_1.StyleEditorClass;\nL.styleEditor = function (map, options) { return new StyleEditorClass_1.StyleEditorClass(map, options); };\nL.Control.StyleEditor = StyleEditorControl_1.StyleEditorControl;\nL.control.styleEditor = function (options) { return new StyleEditorControl_1.StyleEditorControl(options); };\nexports.default = L;\n","module.exports = undefined;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Helper functions used throuhgout the project\n */\nclass UtilOptions {\n}\nexports.UtilOptions = UtilOptions;\nclass Util {\n    constructor(map, options) {\n        this.map = map;\n        this.options = options;\n    }\n    static createInstance(map, options) {\n        Util.instance = new Util(map, options);\n    }\n    static getInstance() {\n        return Util.instance;\n    }\n    // TODO element type\n    fireEvent(eventName, element) {\n        this.map.fireEvent(this.options.styleEditorEventPrefix + eventName, element);\n    }\n    // TODO element type\n    /** fire an event if Leaflet.StyleEditor changed something */\n    fireChangeEvent(element) {\n        this.fireEvent('changed', element);\n    }\n    /** hide the given element */\n    hideElement(element) {\n        if (element) {\n            L.DomUtil.addClass(element, 'leaflet-styleeditor-hidden');\n        }\n    }\n    /** convert rgb to hex of a color\n     * @param {string} rgb - rgb representation of the color\n     * @param {boolean} noHash - define if return value should not include hash\n     */\n    rgbToHex(rgb, noHash = false) {\n        if (!rgb) {\n            rgb = this.options.defaultColor;\n            if (rgb.indexOf('#') !== 0) {\n                rgb = '#' + rgb;\n            }\n        }\n        if (rgb.indexOf('#') === 0) {\n            if (noHash) {\n                rgb.replace('#', '');\n            }\n            return rgb;\n        }\n        if (rgb.indexOf('(') < 0) {\n            return '#' + rgb;\n        }\n        let rgbArray = rgb.substring(4).replace(')', '').split(',');\n        let withoutHash = this._componentToHex(parseInt(rgbArray[0], 10)) + this._componentToHex(parseInt(rgbArray[1], 10)) +\n            this._componentToHex(parseInt(rgbArray[2], 10));\n        if (noHash) {\n            return withoutHash;\n        }\n        return '#' + withoutHash;\n    }\n    /** get element selected to be styled */\n    getCurrentElement() {\n        /**if (!this.styleEditor.currentElement) {\n          return null\n        }\n        if (this.styleEditor.currentElement.target !== undefined) {\n          return this.styleEditor.currentElement.target\n        }\n        return this.styleEditor.currentElement */\n    }\n    /** set which element is selected to be styled */\n    setCurrentElement(currentElement) {\n        /*this.styleEditor.currentElement.target = currentElement*/\n    }\n    /** get current style of current element */\n    getStyle(currentElement, option) {\n        let style = currentElement.options[option];\n        if (style) {\n            return style;\n        }\n        return null;\n    }\n    /** set new style to current element */\n    setStyle(currentElement, option, value) {\n        if (currentElement instanceof L.Marker) {\n            //this.styleEditor.options.markerType.setStyle(currentElement, option, value)\n        }\n        else {\n            let newStyle = {};\n            newStyle[option] = value;\n            currentElement.setStyle(newStyle);\n        }\n        this.fireChangeEvent(currentElement);\n    }\n    /** show hidden element */\n    showElement(element) {\n        if (element) {\n            L.DomUtil.removeClass(element, 'leaflet-styleeditor-hidden');\n        }\n    }\n    /** helper function to convert color to hex */\n    _componentToHex(color) {\n        let hex = color.toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    }\n    /** get the markers for a specific color **/\n    getMarkersForColor(color) {\n        color = this.rgbToHex(color);\n        let markers = []; // TODOthis.styleEditor.options.markerType.options.markers\n        let controlMarkers = []; // TODO this.styleEditor.options.markers\n        if (!Array.isArray(markers)) {\n            // if color is specified return specific markers\n            if (Object.keys(markers).includes(color)) {\n                markers = markers[color];\n            }\n            else {\n                markers = markers['default'];\n            }\n        }\n        if (controlMarkers !== null) {\n            if (!Array.isArray(controlMarkers)) {\n                let keys = Object.keys(controlMarkers);\n                if (keys.includes(color)) {\n                    controlMarkers = controlMarkers[color];\n                }\n                else if (keys.includes('default')) {\n                    controlMarkers = controlMarkers['default'];\n                }\n                else {\n                    controlMarkers = markers;\n                }\n            }\n            return markers.filter((n) => controlMarkers.includes(n));\n        }\n        return markers;\n    }\n    /** get default marker for specific color **/\n    getDefaultMarkerForColor(color) {\n        color = this.rgbToHex(color);\n        let markers = this.getMarkersForColor(color);\n        let defMarkers = [];\n        let defaultMarker = undefined; //TODO this.styleEditor.options.defaultMarkerIcon\n        if (defaultMarker !== null) {\n            if (typeof defaultMarker === 'string') {\n                defMarkers.push(defaultMarker);\n            }\n            if (Object.keys(defaultMarker).includes(color)) {\n                defMarkers.push(defaultMarker[color]);\n            }\n        }\n        defaultMarker = undefined; // TODO this.styleEditor.options.markerType.options.defaultMarkerIcon\n        if (defaultMarker !== undefined) {\n            if (typeof defaultMarker === 'string') {\n                defMarkers.push(defaultMarker);\n            }\n            if (Object.keys(defaultMarker).includes(color)) {\n                defMarkers.push(defaultMarker[color]);\n            }\n        }\n        defMarkers.filter((n) => markers.includes(n));\n        if (defMarkers.length > 0) {\n            return defMarkers[0];\n        }\n        return markers[0];\n    }\n}\nexports.Util = Util;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultStyleEditorControlOptions = {\n    position: 'topleft',\n    strings: {\n        title: 'Style Editor',\n        cancel: 'cancel',\n        cancelTitle: 'cancel'\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultStyleEditorClassOptions = {\n    position: 'topleft',\n    colorRamp: ['#1abc9c', '#2ecc71', '#3498db', '#9b59b6', '#34495e', '#16a085', '#27ae60', '#2980b9', '#8e44ad',\n        '#2c3e50', '#f1c40f', '#e67e22', '#e74c3c', '#ecf0f1', '#95a5a6', '#f39c12', '#d35400', '#c0392b',\n        '#bdc3c7', '#7f8c8d'],\n    defaultColor: null,\n    markerType: undefined,\n    markers: null,\n    defaultMarkerIcon: null,\n    defaultMarkerColor: null,\n    markerForm: undefined,\n    geometryForm: undefined,\n    ignoreLayerTypes: [],\n    forms: {},\n    events: [],\n    openOnLeafletDraw: true,\n    openOnLeafletEditable: true,\n    showTooltip: true,\n    strings: {\n        tooltip: 'Click on the element you want to style',\n        tooltipNext: 'Choose another element you want to style',\n    },\n    useGrouping: true,\n    styleEditorEventPrefix: 'styleeditor:',\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _1 = require(\".\");\nexports.DefaultStyleEditorOptions = Object.assign(Object.assign({}, _1.DefaultStyleEditorClassOptions), _1.DefaultStyleEditorControlOptions);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StyleEditorClass_1 = require(\"./StyleEditorClass\");\nconst options_1 = require(\"./options\");\n/**\n * StyleEditorControl creates a { L.Control }\n * which enables the user to enable and disable Leaflet.StyleEditor\n */\nclass StyleEditorControl extends L.Control {\n    constructor(options, styleEditor, styleEditorOptions) {\n        super();\n        this.isEnabled = false;\n        if (styleEditorOptions === undefined) {\n            this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorControlOptions), options);\n            this.styleEditor = styleEditor;\n        }\n        else {\n            this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorControlOptions), styleEditorOptions);\n            this.styleEditorClassOptions = Object.assign(Object.assign({}, options_1.DefaultStyleEditorClassOptions), styleEditorOptions);\n        }\n    }\n    /**\n     * Create the Control element and its HTMLElements\n     * @param map the map where the control should be added to\n     */\n    onAdd(map) {\n        if (this.styleEditor === undefined) {\n            this.styleEditor = new StyleEditorClass_1.StyleEditorClass(map, this.styleEditorClassOptions);\n        }\n        // disable styleEditor if using control element\n        this.styleEditor.disable();\n        return this.createUI();\n    }\n    createUI() {\n        const controlUI = L.DomUtil.create('div', 'leaflet-control-styleeditor leaflet-control leaflet-bar');\n        const controlDiv = L.DomUtil.create('a', 'leaflet-control-styleeditor-interior', controlUI);\n        controlDiv.title = this.options.strings.title;\n        const cancelUI = this.cancelUI = L.DomUtil.create('div', 'leaflet-control-styleeditor-cancel leaflet-styleeditor-hidden', controlUI);\n        cancelUI.innerHTML = this.options.strings.cancel;\n        cancelUI.title = this.options.strings.cancelTitle;\n        L.DomEvent.disableScrollPropagation(controlUI);\n        L.DomEvent.disableScrollPropagation(cancelUI);\n        L.DomEvent.disableClickPropagation(controlUI);\n        L.DomEvent.disableClickPropagation(cancelUI);\n        // toggle UI visibility\n        L.DomEvent.on(controlUI, 'click', this.toggle, this);\n        return controlUI;\n    }\n    toggle() {\n        if (this.isEnabled) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n    }\n    enable() {\n        this.isEnabled = true;\n        this.showCancelButton();\n        this.styleEditor.enable();\n    }\n    disable() {\n        if (this.isEnabled) {\n            this.isEnabled = false;\n            this.hideCancelButton();\n            this.styleEditor.disable();\n        }\n    }\n    showCancelButton() {\n        L.DomUtil.removeClass(this.cancelUI, 'leaflet-styleeditor-hidden');\n    }\n    hideCancelButton() {\n        L.DomUtil.addClass(this.cancelUI, 'leaflet-styleeditor-hidden');\n    }\n}\nexports.StyleEditorControl = StyleEditorControl;\n"],"sourceRoot":""}