{"version":3,"sources":["webpack://leafletstyleeditor/webpack/bootstrap","webpack://leafletstyleeditor/./src/typescript/Util.ts","webpack://leafletstyleeditor/./src/typescript/options/index.ts","webpack://leafletstyleeditor/./src/typescript/StyleEditorClass.ts","webpack://leafletstyleeditor/./src/typescript/form/index.ts","webpack://leafletstyleeditor/./src/typescript/formElements/FormElement.ts","webpack://leafletstyleeditor/./src/typescript/index.ts","webpack://leafletstyleeditor/external {\"commonjs\":\"leaflet\",\"amd\":\"leaflet\",\"root\":\"L\"}","webpack://leafletstyleeditor/./src/typescript/StyleForm.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorControlOptions.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorClassOptions.ts","webpack://leafletstyleeditor/./src/typescript/form/Form.ts","webpack://leafletstyleeditor/./src/typescript/form/MarkerForm.ts","webpack://leafletstyleeditor/./src/typescript/formElements/index.ts","webpack://leafletstyleeditor/./src/typescript/formElements/ColorElement.ts","webpack://leafletstyleeditor/./src/typescript/options/StyleEditorOptions.ts","webpack://leafletstyleeditor/./src/typescript/StyleEditorControl.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","UtilOptions","Util","map","options","this","instance","eventName","element","fireEvent","styleEditorEventPrefix","L","DomUtil","addClass","rgb","noHash","defaultColor","indexOf","replace","rgbArray","substring","split","withoutHash","_componentToHex","parseInt","currentElement","option","style","Marker","newStyle","setStyle","fireChangeEvent","removeClass","color","hex","toString","length","rgbToHex","markers","controlMarkers","Array","isArray","keys","includes","filter","getMarkersForColor","defMarkers","defaultMarker","undefined","push","StyleEditorControlOptions_1","DefaultStyleEditorControlOptions","StyleEditorClassOptions_1","DefaultStyleEditorClassOptions","StyleEditorOptions_1","DefaultStyleEditorOptions","StyleForm_1","Util_1","options_1","StyleEditorClass","Class","super","assign","createInstance","createUi","editorUI","getContainer","styleEditorHeader","styleEditorInterior","buttonNext","title","strings","hide","tooltipWrapper","tooltipUI","innerHTML","tooltip","DomEvent","disableScrollPropagation","disableClickPropagation","on","onNext","addEventListeners","StyleForm","markerForm","geometryForm","events","forEach","event","onEvent","hideEditor","showTooltip","stopPropagation","children","getPanes","markerPane","index","layer","layerIsIgnored","useGrouping","LayerGroup","Path","ignoreLayerTypes","some","layerType","styleEditor","type","toUpperCase","removeIndicators","showEditor","hideTooltip","Form_1","Form","MarkerForm_1","MarkerForm","FormElement","styleOption","parentForm","parentUiElement","util","getInstance","uiElement","createTitle","createContent","showForm","showElement","hideElement","layers","Layer","getLayers","StyleEditorClass_1","StyleEditorControl_1","StyleEditor","Control","StyleEditorControl","control","default","styleEditorDiv","createMarkerForm","createGeometryForm","addDOMEvents","addListener","lostFocus","clearForm","show","e","parent","target","className","hasClass","parentNode","position","cancel","cancelTitle","form_1","colorRamp","markerType","defaultMarkerIcon","defaultMarkerColor","forms","openOnLeafletDraw","openOnLeafletEditable","formOptionKey","formElements","initializedElements","formOptionsKey","formElement","getFormElementClass","hideFormElements","hideForm","preShow","showFormElements","showFormElement","showFormElementForStyleOption","getFormElementStandardClass","_1","formElements_1","ColorElement","__importDefault","mod","ColorElement_1","FormElement_1","colorPickerDiv","getColorRamp","setSelectCallback","elem","backgroundColor","selectColor","styleEditorOptions","isEnabled","styleEditorClassOptions","disable","createUI","controlUI","cancelUI","toggle","enable","showCancelButton","hideCancelButton"],"mappings":"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","file":"javascript/Leaflet.StyleEditor.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Helper functions used throuhgout the project\n */\nclass UtilOptions {\n}\nexports.UtilOptions = UtilOptions;\nclass Util {\n    constructor(map, options) {\n        this.map = map;\n        this.options = options;\n    }\n    static createInstance(map, options) {\n        Util.instance = new Util(map, options);\n    }\n    static getInstance() {\n        return Util.instance;\n    }\n    // TODO element type\n    fireEvent(eventName, element) {\n        this.map.fireEvent(this.options.styleEditorEventPrefix + eventName, element);\n    }\n    // TODO element type\n    /** fire an event if Leaflet.StyleEditor changed something */\n    fireChangeEvent(element) {\n        this.fireEvent('changed', element);\n    }\n    /** hide the given element */\n    hideElement(element) {\n        if (element) {\n            L.DomUtil.addClass(element, 'leaflet-styleeditor-hidden');\n        }\n    }\n    /** convert rgb to hex of a color\n     * @param {string} rgb - rgb representation of the color\n     * @param {boolean} noHash - define if return value should not include hash\n     */\n    rgbToHex(rgb, noHash = false) {\n        if (!rgb) {\n            rgb = this.options.defaultColor;\n            if (rgb.indexOf('#') !== 0) {\n                rgb = '#' + rgb;\n            }\n        }\n        if (rgb.indexOf('#') === 0) {\n            if (noHash) {\n                rgb.replace('#', '');\n            }\n            return rgb;\n        }\n        if (rgb.indexOf('(') < 0) {\n            return '#' + rgb;\n        }\n        let rgbArray = rgb.substring(4).replace(')', '').split(',');\n        let withoutHash = this._componentToHex(parseInt(rgbArray[0], 10)) + this._componentToHex(parseInt(rgbArray[1], 10)) +\n            this._componentToHex(parseInt(rgbArray[2], 10));\n        if (noHash) {\n            return withoutHash;\n        }\n        return '#' + withoutHash;\n    }\n    /** get element selected to be styled */\n    getCurrentElement() {\n        /**if (!this.styleEditor.currentElement) {\n          return null\n        }\n        if (this.styleEditor.currentElement.target !== undefined) {\n          return this.styleEditor.currentElement.target\n        }\n        return this.styleEditor.currentElement */\n    }\n    /** set which element is selected to be styled */\n    setCurrentElement(currentElement) {\n        /*this.styleEditor.currentElement.target = currentElement*/\n    }\n    /** get current style of current element */\n    getStyle(currentElement, option) {\n        let style = currentElement.options[option];\n        if (style) {\n            return style;\n        }\n        return null;\n    }\n    /** set new style to current element */\n    setStyle(currentElement, option, value) {\n        if (currentElement instanceof L.Marker) {\n            //this.styleEditor.options.markerType.setStyle(currentElement, option, value)\n        }\n        else {\n            let newStyle = {};\n            newStyle[option] = value;\n            currentElement.setStyle(newStyle);\n        }\n        this.fireChangeEvent(currentElement);\n    }\n    /** show hidden element */\n    showElement(element) {\n        if (element) {\n            L.DomUtil.removeClass(element, 'leaflet-styleeditor-hidden');\n        }\n    }\n    /** helper function to convert color to hex */\n    _componentToHex(color) {\n        let hex = color.toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    }\n    /** get the markers for a specific color **/\n    getMarkersForColor(color) {\n        color = this.rgbToHex(color);\n        let markers = []; // TODOthis.styleEditor.options.markerType.options.markers\n        let controlMarkers = []; // TODO this.styleEditor.options.markers\n        if (!Array.isArray(markers)) {\n            // if color is specified return specific markers\n            if (Object.keys(markers).includes(color)) {\n                markers = markers[color];\n            }\n            else {\n                markers = markers['default'];\n            }\n        }\n        if (controlMarkers !== null) {\n            if (!Array.isArray(controlMarkers)) {\n                let keys = Object.keys(controlMarkers);\n                if (keys.includes(color)) {\n                    controlMarkers = controlMarkers[color];\n                }\n                else if (keys.includes('default')) {\n                    controlMarkers = controlMarkers['default'];\n                }\n                else {\n                    controlMarkers = markers;\n                }\n            }\n            return markers.filter((n) => controlMarkers.includes(n));\n        }\n        return markers;\n    }\n    /** get default marker for specific color **/\n    getDefaultMarkerForColor(color) {\n        color = this.rgbToHex(color);\n        let markers = this.getMarkersForColor(color);\n        let defMarkers = [];\n        let defaultMarker = undefined; //TODO this.styleEditor.options.defaultMarkerIcon\n        if (defaultMarker !== null) {\n            if (typeof defaultMarker === 'string') {\n                defMarkers.push(defaultMarker);\n            }\n            if (Object.keys(defaultMarker).includes(color)) {\n                defMarkers.push(defaultMarker[color]);\n            }\n        }\n        defaultMarker = undefined; // TODO this.styleEditor.options.markerType.options.defaultMarkerIcon\n        if (defaultMarker !== undefined) {\n            if (typeof defaultMarker === 'string') {\n                defMarkers.push(defaultMarker);\n            }\n            if (Object.keys(defaultMarker).includes(color)) {\n                defMarkers.push(defaultMarker[color]);\n            }\n        }\n        defMarkers.filter((n) => markers.includes(n));\n        if (defMarkers.length > 0) {\n            return defMarkers[0];\n        }\n        return markers[0];\n    }\n}\nexports.Util = Util;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StyleEditorControlOptions_1 = require(\"./StyleEditorControlOptions\");\nexports.DefaultStyleEditorControlOptions = StyleEditorControlOptions_1.DefaultStyleEditorControlOptions;\nconst StyleEditorClassOptions_1 = require(\"./StyleEditorClassOptions\");\nexports.DefaultStyleEditorClassOptions = StyleEditorClassOptions_1.DefaultStyleEditorClassOptions;\nconst StyleEditorOptions_1 = require(\"./StyleEditorOptions\");\nexports.DefaultStyleEditorOptions = StyleEditorOptions_1.DefaultStyleEditorOptions;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StyleForm_1 = require(\"./StyleForm\");\nconst Util_1 = require(\"./Util\");\nconst options_1 = require(\"./options\");\nclass StyleEditorClass extends L.Class {\n    constructor(map, options) {\n        super();\n        this.map = map;\n        this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorOptions), options);\n        Util_1.Util.createInstance(map, this.options);\n        this.createUi();\n    }\n    createUi() {\n        const editorUI = this.editorUI = L.DomUtil.create('div', 'leaflet-styleeditor', this.map.getContainer());\n        const styleEditorHeader = L.DomUtil.create('div', 'leaflet-styleeditor-header', editorUI);\n        const styleEditorInterior = L.DomUtil.create('div', 'leaflet-styleeditor-interior', editorUI);\n        const buttonNext = L.DomUtil.create('button', 'leaflet-styleeditor-button styleeditor-hideBtn', styleEditorHeader);\n        buttonNext.title = this.options.strings.hide;\n        const tooltipWrapper = this.tooltipUI = L.DomUtil.create('div', 'leaflet-styleeditor-tooltip-wrapper', this.map.getContainer());\n        const tooltip = L.DomUtil.create('div', 'leaflet-styleeditor-tooltip', tooltipWrapper);\n        tooltip.innerHTML = this.options.strings.tooltip;\n        // do not propagate scrolling events on the ui to the map\n        L.DomEvent.disableScrollPropagation(editorUI);\n        L.DomEvent.disableScrollPropagation(buttonNext);\n        // do not propagate click events on the ui to the map\n        L.DomEvent.disableClickPropagation(editorUI);\n        L.DomEvent.disableClickPropagation(buttonNext);\n        // select next layer to style\n        L.DomEvent.on(buttonNext, 'click', this.onNext, this);\n        this.addEventListeners(this.map);\n        new StyleForm_1.StyleForm(this.map, editorUI, styleEditorInterior, this.options.markerForm, this.options.geometryForm);\n    }\n    addEventListeners(map) {\n        this.options.events.forEach(event => map.on(event, this.onEvent));\n    }\n    onEvent(event) {\n        // TODO\n    }\n    onNext(event) {\n        this.hideEditor();\n        this.showTooltip();\n        event.stopPropagation();\n    }\n    removeIndicators() {\n        const children = this.map.getPanes().markerPane.children;\n        for (let index = 0; index < children.length; index++) {\n            const element = children[index];\n            L.DomUtil.removeClass(element, 'leaflet-styleeditor-marker-selected');\n        }\n    }\n    addEditClickEvents(layer) {\n        if (this.layerIsIgnored(layer)) {\n            return;\n        }\n        if (this.options.useGrouping && layer instanceof L.LayerGroup) {\n            //this.options._layerGroups.push(layer)\n        }\n        else if (layer instanceof L.Marker || layer instanceof L.Path) {\n            //let evt = layer.on('click', this.initChangeStyle, this)\n            //this.options._editLayers.push(evt)\n        }\n    }\n    layerIsIgnored(layer) {\n        if (layer === undefined) {\n            return false;\n        }\n        return this.options.ignoreLayerTypes.some(layerType => layer.styleEditor && layer.styleEditor.type.toUpperCase() === layerType.toUpperCase());\n    }\n    hideEditor() {\n        L.DomUtil.removeClass(this.editorUI, 'editor-enabled');\n        this.removeIndicators();\n        this.fireEvent('hidden');\n    }\n    showEditor() {\n        L.DomUtil.addClass(this.editorUI, 'editor-enabled');\n        this.fireEvent('visible');\n    }\n    showTooltip() {\n        L.DomUtil.removeClass(this.tooltipUI, 'leaflet-styleeditor-hidden');\n    }\n    hideTooltip() {\n        L.DomUtil.addClass(this.tooltipUI, 'leaflet-styleeditor-hidden');\n    }\n    fireEvent(eventName) {\n    }\n    enable() {\n        //TODO this.addClickEvents()\n        this.showTooltip();\n        this.showEditor();\n    }\n    disable() {\n        //TODO this.removeClickEvents()\n        this.hideTooltip();\n        this.hideEditor();\n    }\n}\nexports.StyleEditorClass = StyleEditorClass;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Form_1 = require(\"./Form\");\nexports.Form = Form_1.Form;\nconst MarkerForm_1 = require(\"./MarkerForm\");\nexports.MarkerForm = MarkerForm_1.MarkerForm;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = require(\"../Util\");\n/** FormElements are part of a Form for a specific styling option (i.e. color) */\nclass FormElement {\n    /* TODO\n    // if no title is given use styling option\n    if(!this.options.title && !!this.options.styleOption) {\n    this.options.title = this.options.styleOption.charAt(0).toUpperCase() + this.options.styleOption.slice(1)\n  }*/\n    constructor(styleOption, parentForm, parentUiElement, title) {\n        this.util = Util_1.Util.getInstance();\n        this.styleOption = styleOption;\n        this.title = title || styleOption;\n        this.parentForm = parentForm;\n        this.create(parentUiElement);\n    }\n    /** create uiElement and content */\n    create(parentUiElement) {\n        this.uiElement =\n            L.DomUtil.create('div', 'leaflet-styleeditor-uiElement', parentUiElement);\n        this.createTitle();\n        this.createContent();\n    }\n    /** create title */\n    createTitle() {\n        let title = L.DomUtil.create('label', 'leaflet-styleeditor-label', this.uiElement);\n        title.innerHTML = this.title + ':';\n    }\n    /** create content (where the actual modification takes place) */\n    createContent() {\n    }\n    /** style the FormElement and show it */\n    show(currentElement) {\n        this.style(currentElement);\n        this.showForm();\n    }\n    /** show the FormElement */\n    showForm() {\n        this.util.showElement(this.uiElement);\n    }\n    /** hide the FormElement */\n    hide() {\n        this.util.hideElement(this.uiElement);\n    }\n    /** style the FormElement */\n    style(currentElement) {\n    }\n    /** what to do when lost focus */\n    lostFocus() {\n    }\n    /** set style - used when the FormElement wants to change the styling option */\n    setStyle(value, currentElement) {\n        // check whether a layer is part of a layerGroup\n        let layers = L.Layer[currentElement];\n        if (currentElement instanceof L.LayerGroup) {\n            layers = currentElement.getLayers;\n        }\n        // update layer (or all layers of a layerGroup)\n        for (let i = 0; i < layers.length; i++) {\n            let layer = layers[i];\n            if (layer instanceof L.Marker) {\n                //TODO layer.setStyle(currentElement, this.options.styleOption, value)\n            }\n            else {\n                let newStyle = {};\n                newStyle[this.styleOption] = value;\n                layer.setStyle(newStyle);\n                layer.options[this.styleOption] = value;\n            }\n            // fire event for changed layer\n            this.util.fireChangeEvent(layer);\n        }\n        // notify form styling value has changed\n        this.parentForm.style();\n    }\n}\nexports.FormElement = FormElement;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"leaflet\");\nconst StyleEditorClass_1 = require(\"./StyleEditorClass\");\nconst StyleEditorControl_1 = require(\"./StyleEditorControl\");\nrequire('../css/Leaflet.StyleEditor.css');\nL.StyleEditor = StyleEditorClass_1.StyleEditorClass;\nL.styleEditor = function (map, options) { return new StyleEditorClass_1.StyleEditorClass(map, options); };\nL.Control.StyleEditor = StyleEditorControl_1.StyleEditorControl;\nL.control.styleEditor = function (options) { return new StyleEditorControl_1.StyleEditorControl(options); };\nexports.default = L;\n","module.exports = undefined;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = require(\"./Util\");\nclass StyleForm {\n    constructor(map, styleEditorDiv, styleEditorInterior, markerForm, geometryForm) {\n        this.util = Util_1.Util.getInstance();\n        this.map = map;\n        this.styleEditorDiv = styleEditorDiv;\n        this.styleEditorInterior = styleEditorInterior;\n        this.markerForm = this.createMarkerForm(markerForm);\n        this.geometryForm = this.createGeometryForm(geometryForm);\n        this.addDOMEvents();\n    }\n    addDOMEvents() {\n        L.DomEvent.addListener(this.map, 'click', this.lostFocus, this);\n        L.DomEvent.addListener(this.styleEditorDiv, 'click', this.lostFocus, this);\n    }\n    clearForm() {\n        this.markerForm.hide();\n        this.geometryForm.hide();\n    }\n    createMarkerForm(markerForm) {\n        let markerDiv = L.DomUtil.create('div', 'leaflet-styleeditor-interior-marker', this.styleEditorInterior);\n        return new markerForm(markerDiv);\n    }\n    createGeometryForm(geometryForm) {\n        let markerDiv = L.DomUtil.create('div', 'leaflet-styleeditor-interior-geometry', this.styleEditorInterior);\n        return new geometryForm(markerDiv);\n    }\n    showMarkerForm() {\n        this.clearForm();\n        this.markerForm.show();\n    }\n    showGeometryForm() {\n        this.clearForm();\n        this.geometryForm.show();\n    }\n    fireChangeEvent(element) {\n        this.util.fireChangeEvent(element);\n    }\n    lostFocus(e) {\n        let parent = e.target;\n        for (let i = 0; i < 10; i++) {\n            if (!parent) {\n                break;\n            }\n            if (!!parent.className && L.DomUtil.hasClass(parent, 'leaflet-styleeditor-interior')) {\n                return;\n            }\n            parent = parent.parentNode;\n        }\n        this.markerForm.lostFocus();\n        this.geometryForm.lostFocus();\n    }\n}\nexports.StyleForm = StyleForm;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultStyleEditorControlOptions = {\n    position: 'topleft',\n    strings: {\n        title: 'Style Editor',\n        cancel: 'cancel',\n        cancelTitle: 'cancel'\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst form_1 = require(\"../form\");\nexports.DefaultStyleEditorClassOptions = {\n    position: 'topleft',\n    colorRamp: ['#1abc9c', '#2ecc71', '#3498db', '#9b59b6', '#34495e', '#16a085', '#27ae60', '#2980b9', '#8e44ad',\n        '#2c3e50', '#f1c40f', '#e67e22', '#e74c3c', '#ecf0f1', '#95a5a6', '#f39c12', '#d35400', '#c0392b',\n        '#bdc3c7', '#7f8c8d'],\n    defaultColor: null,\n    markerType: undefined,\n    markers: null,\n    defaultMarkerIcon: null,\n    defaultMarkerColor: null,\n    markerForm: form_1.MarkerForm,\n    geometryForm: form_1.MarkerForm,\n    ignoreLayerTypes: [],\n    forms: {},\n    events: [],\n    openOnLeafletDraw: true,\n    openOnLeafletEditable: true,\n    showTooltip: true,\n    strings: {\n        tooltip: 'Click on the element you want to style',\n        hide: 'Hide Style Editor',\n    },\n    useGrouping: true,\n    styleEditorEventPrefix: 'styleeditor:',\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = require(\"../Util\");\n/**\n * Forms consist of FormElements and are shown in the StyleForm\n * There exists a MarkerForm to modify Markers and a GeometryForm to modify Geometries (i.e. rectangles...)\n * Style options based on:\n *     - path: https://leafletjs.com/reference.html#path-options\n *     - icon: https://leafletjs.com/reference.html#icon\n */\nclass Form {\n    constructor(formOptionKey, parentUiElement, formElements) {\n        this.initializedElements = {};\n        this.util = Util_1.Util.getInstance();\n        this.formOptionsKey = formOptionKey;\n        this.parentUiElement = parentUiElement;\n        this.formElements = formElements;\n        this.create();\n    }\n    /** create every FormElement in the parentUiElement */\n    create() {\n        for (let key in this.formElements) {\n            const formElement = this.getFormElementClass(key);\n            if (formElement !== undefined) {\n                this.initializedElements[key] = new formElement(this, this.parentUiElement);\n            }\n        }\n    }\n    /** hide the Form including its FormElements */\n    hide() {\n        this.hideFormElements();\n        this.hideForm();\n    }\n    /** hide the FormElements */\n    hideFormElements() {\n        for (let key in this.initializedElements) {\n            this.initializedElements[key].hide();\n        }\n    }\n    /** hide the Form */\n    hideForm() {\n        this.util.hideElement(this.parentUiElement);\n    }\n    /** make FormElements and Form visible */\n    show(currentElement) {\n        this.preShow();\n        this.showFormElements();\n        this.showForm();\n        this.style(currentElement);\n    }\n    /** hook which is called at the beginning of the show function */\n    preShow() {\n    }\n    /** make every FormElement visible */\n    showFormElements() {\n        for (let key in this.initializedElements) {\n            this.showFormElement(this.initializedElements[key]);\n        }\n    }\n    /** make the Form visible */\n    showForm() {\n        this.util.showElement(this.parentUiElement);\n    }\n    /** inform FormElements the selected style has changed, so they can adapt */\n    style(currentElement) {\n        for (let key in this.initializedElements) {\n            this.initializedElements[key].style(currentElement);\n        }\n    }\n    /** inform Form it lost it's focus */\n    lostFocus() {\n        for (let key in this.initializedElements) {\n            this.initializedElements[key].lostFocus();\n        }\n    }\n    /**\n     * @returns a Boolean indicating if the @param formElement should be shown\n     */\n    showFormElement(formElement) {\n        // check wether element should be shown or not\n        if (this.showFormElementForStyleOption(formElement.styleOption)) {\n            formElement.show();\n        }\n        else {\n            formElement.hide();\n        }\n    }\n    /**\n     * get the Class of the Formelement to instanciate\n     * @param {*} styleOption, the styleOption to get the FormElement for\n     */\n    getFormElementClass(styleOption) {\n        let formElementKeys = Object.keys(this.formElements);\n        if (formElementKeys.indexOf(styleOption) >= 0) {\n            let FormElement = this.formElements[styleOption];\n            if (FormElement) {\n                // may be a dictionary\n                if (typeof FormElement === 'boolean') {\n                    return this.getFormElementStandardClass(styleOption);\n                }\n                if ('formElement' in FormElement && 'boolean' in FormElement) {\n                    FormElement = FormElement['formElement'];\n                }\n            }\n            // if nothing works return it\n            return this.getFormElementStandardClass(styleOption);\n        }\n    }\n    /**\n     * check whether a FormElement should be shown\n     * @param {*} styleOption, the styleOption to check\n     */\n    showFormElementForStyleOption(styleOption) {\n        /*\n        if (styleOption in this.formElements) {\n          let styleFormElement = this.initializedElements[styleOption]\n    \n          // maybe a function is given to declare when to show the FormElement\n          if (typeof styleFormElement === 'function') {\n            try {\n              return styleFormElement(this.util.getCurrentElement())\n            } catch (err) {\n              // the given function presumably is a constructor -> always show it\n              return true\n            }\n          }\n    \n          // maybe a boolean is given to indicate whether to show it\n          if (typeof styleFormElement === 'boolean') {\n            return styleFormElement\n          }\n    \n          // check for dictionary\n          if ('boolean' in styleFormElement) {\n            // in a dictionary boolean may be a function or boolean\n            if (typeof styleFormElement['boolean'] === 'function') {\n              return styleFormElement['boolean'](this.util.getCurrentElement())\n            }\n            return styleFormElement['boolean']\n          }\n          return true\n        }\n        TODO */\n        return false;\n    }\n    /**\n     * get Leaflet.StyleEditor standard FormElement class for given styleOption\n     * @param {*} styleOption, the styleOption to get the standard class for\n     */\n    getFormElementStandardClass(styleOption) {\n        return this.formElements[styleOption];\n    }\n}\nexports.Form = Form;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _1 = require(\".\");\nconst formElements_1 = require(\"../formElements\");\nconst formOptionKey = 'marker';\nconst formElements = {\n    //'icon': new IconElement(),\n    'color': formElements_1.ColorElement\n    //'size': new SizeElement(),\n    //'popupContent': new PopupContentElement()\n};\n/** Form used to enable modification of a Geometry */\nclass MarkerForm extends _1.Form {\n    constructor(parentUiElement) {\n        super(formOptionKey, parentUiElement, formElements);\n    }\n}\nexports.MarkerForm = MarkerForm;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ColorElement_1 = __importDefault(require(\"./ColorElement\"));\nexports.ColorElement = ColorElement_1.default;\nconst FormElement_1 = require(\"./FormElement\");\nexports.FormElement = FormElement_1.FormElement;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FormElement_1 = require(\"./FormElement\");\nconst title = \"color\";\nconst styleOption = \"color\";\n/**\n *  FormElement used to style the color\n */\nclass ColorElement extends FormElement_1.FormElement {\n    constructor(parentForm, parentUiElement) {\n        super(styleOption, parentForm, parentUiElement, title);\n    }\n    createContent() {\n        this.colorPickerDiv = L.DomUtil.create('div', 'leaflet-styleeditor-colorpicker', this.uiElement);\n        this.getColorRamp().forEach(this.setSelectCallback, this);\n    }\n    /** create of get already created colorRamp */\n    getColorRamp() {\n        /* TODO\n        if (!this.options.colorRamp) {\n          // if markers have own colorRamp use it\n          if (this.options.parentForm instanceof MarkerForm && !!this.styleEditor.options.markerType.options.colorRamp) {\n            this.options.colorRamp = this.styleEditor.options.markerType.options.colorRamp\n            // else use the default\n          } else {\n            this.options.colorRamp = this.styleEditor.options.colorRamp\n          }\n        }\n        return this.options.colorRamp */\n        return ['#000'];\n    }\n    /** define what to do when color is changed */\n    setSelectCallback(color) {\n        let elem = L.DomUtil.create('div', 'leaflet-styleeditor-color', this.colorPickerDiv);\n        elem.style.backgroundColor = color;\n        L.DomEvent.addListener(elem, 'click', this.selectColor, this);\n    }\n    /** set style for chosen color */\n    selectColor(e) {\n        e.stopPropagation();\n        this.setStyle(this.util.rgbToHex(e.target.style.backgroundColor));\n        // marker styling needs additional function calls\n        if (e.target instanceof L.Marker) {\n            // TODO this.styleEditor.options.markerType.setNewMarker(e)\n        }\n    }\n}\nexports.default = ColorElement;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _1 = require(\".\");\nexports.DefaultStyleEditorOptions = Object.assign(Object.assign(Object.assign({}, _1.DefaultStyleEditorClassOptions), _1.DefaultStyleEditorControlOptions), { strings: {\n        title: _1.DefaultStyleEditorControlOptions.strings.title,\n        cancel: _1.DefaultStyleEditorControlOptions.strings.cancel,\n        cancelTitle: _1.DefaultStyleEditorControlOptions.strings.cancelTitle,\n        tooltip: _1.DefaultStyleEditorClassOptions.strings.tooltip,\n        hide: _1.DefaultStyleEditorClassOptions.strings.hide\n    } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StyleEditorClass_1 = require(\"./StyleEditorClass\");\nconst options_1 = require(\"./options\");\n/**\n * StyleEditorControl creates a { L.Control }\n * which enables the user to enable and disable Leaflet.StyleEditor\n */\nclass StyleEditorControl extends L.Control {\n    constructor(options, styleEditor, styleEditorOptions) {\n        super();\n        this.isEnabled = false;\n        if (styleEditorOptions === undefined) {\n            this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorControlOptions), options);\n            this.styleEditor = styleEditor;\n        }\n        else {\n            this.options = Object.assign(Object.assign({}, options_1.DefaultStyleEditorControlOptions), styleEditorOptions);\n            this.styleEditorClassOptions = Object.assign(Object.assign({}, options_1.DefaultStyleEditorClassOptions), styleEditorOptions);\n        }\n    }\n    /**\n     * Create the Control element and its HTMLElements\n     * @param map the map where the control should be added to\n     */\n    onAdd(map) {\n        if (this.styleEditor === undefined) {\n            this.styleEditor = new StyleEditorClass_1.StyleEditorClass(map, this.styleEditorClassOptions);\n        }\n        // disable styleEditor if using control element\n        this.styleEditor.disable();\n        return this.createUI();\n    }\n    createUI() {\n        const controlUI = L.DomUtil.create('div', 'leaflet-control-styleeditor leaflet-control leaflet-bar');\n        const controlDiv = L.DomUtil.create('a', 'leaflet-control-styleeditor-interior', controlUI);\n        controlDiv.title = this.options.strings.title;\n        const cancelUI = this.cancelUI = L.DomUtil.create('div', 'leaflet-control-styleeditor-cancel leaflet-styleeditor-hidden', controlUI);\n        cancelUI.innerHTML = this.options.strings.cancel;\n        cancelUI.title = this.options.strings.cancelTitle;\n        L.DomEvent.disableScrollPropagation(controlUI);\n        L.DomEvent.disableScrollPropagation(cancelUI);\n        L.DomEvent.disableClickPropagation(controlUI);\n        L.DomEvent.disableClickPropagation(cancelUI);\n        // toggle UI visibility\n        L.DomEvent.on(controlUI, 'click', this.toggle, this);\n        return controlUI;\n    }\n    toggle() {\n        if (this.isEnabled) {\n            this.disable();\n        }\n        else {\n            this.enable();\n        }\n    }\n    enable() {\n        this.isEnabled = true;\n        this.showCancelButton();\n        this.styleEditor.enable();\n    }\n    disable() {\n        if (this.isEnabled) {\n            this.isEnabled = false;\n            this.hideCancelButton();\n            this.styleEditor.disable();\n        }\n    }\n    showCancelButton() {\n        L.DomUtil.removeClass(this.cancelUI, 'leaflet-styleeditor-hidden');\n    }\n    hideCancelButton() {\n        L.DomUtil.addClass(this.cancelUI, 'leaflet-styleeditor-hidden');\n    }\n}\nexports.StyleEditorControl = StyleEditorControl;\n"],"sourceRoot":""}